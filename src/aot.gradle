// For AOT benchmarks use -O3 optimisation level. But -Os for everything else
tasks.whenTaskAdded { task ->
    if (task.name.startsWith("compileDarjeelingExecutableDarjeelingBm_")) {
        ext.needToRestoreOs = false
        task.doFirst {
            binaries.all {
                if (cCompiler.args.contains("-Os")) {
                    println "============= SETTING -O3"
                    println cCompiler.args
                    ext.needToRestoreOs = true
                    cCompiler.args.remove "-Os"
                    cCompiler.args "-O3"
                    println cCompiler.args
                } else {
                    ext.needToRestoreOs = false
                }
            }
        }
        task.doLast {
            binaries.all {
                if (ext.needToRestoreOs) {
                    println "============= RESTORING -Os"
                    println cCompiler.args
                    ext.needToRestoreOs = false
                    cCompiler.args.remove "-O3"
                    cCompiler.args "-Os"
                    println cCompiler.args
                }
            }
        }
    }
}

// Each benchmark implements the same interface, so this app can use any.
// But the link in the infusion from the app infusion to the lib infusion is on library name
// so we still need to recompile the app when the benchmark library changes, or we'll
// get a "link not satisfied" panic at run time.
tasks.whenTaskAdded { task ->
    if (task.name == 'infusion_apprtcbench') {
        task.inputs.property("aotbm", project.aotbm)
    }
}

// DEFAULTS
if (!project.hasProperty('aotstrat')) {
    project.ext.aotstrat = 'markloop'
}
if (project.ext.aotstrat == 'peephole') { project.ext.aotstrat = 'improvedpeephole' }
if (project.ext.aotstrat == 'simple') { project.ext.aotstrat = 'simplestackcache' }
if (project.ext.aotstrat == 'popped') { project.ext.aotstrat = 'poppedstackcache' }
if (!project.hasProperty('aotbm')) {
    project.ext.aotbm = 'bsort32'
}
if (!project.hasProperty('aotstackcachesize')) {
    project.ext.aotstackcachesize = '11'
}

if (project.hasProperty('no-opcode-optimisations')) {
    project.ext.use16bitarrayindex = 'false'
    project.ext.useconstantshiftoptimisation = 'false'
    project.ext.usesimul = 'false'
    project.ext.usegetfield_a_fixed = 'false'
}

if (!project.hasProperty('safer')) {
    project.ext.safer = 'false'
} else {
    if (project.ext.safer == '') {
        project.ext.safer = 'true'        
    }
    if (project.ext.safer != 'true'
            && project.ext.safer != 'false') {
        throw new InvalidUserDataException("Invalid value for safer" + project.ext.safer)        
    }
    if (project.ext.safer == 'true') {
        project.ext.safe = 'true'        
    }
}

if (!project.hasProperty('safe')) {
    project.ext.safe = 'false'
} else {
    if (project.ext.safe == '') {
        project.ext.safe = 'true'        
    }
    if (project.ext.safe != 'true'
            && project.ext.safe != 'false') {
        throw new InvalidUserDataException("Invalid value for safe" + project.ext.safe)        
    }
}

if (!project.hasProperty('uselightweightmethods')) {
    project.ext.uselightweightmethods = 'true'
} else {
    if (project.ext.uselightweightmethods == '') {
        project.ext.uselightweightmethods = 'true'        
    }
    if (project.ext.uselightweightmethods != 'true'
            && project.ext.uselightweightmethods != 'false') {
        throw new InvalidUserDataException("Invalid value for uselightweightmethods" + project.ext.uselightweightmethods)        
    }
}

if (!project.hasProperty('use16bitarrayindex')) {
    project.ext.use16bitarrayindex = 'true'
} else {
    if (project.ext.use16bitarrayindex == '') {
        project.ext.use16bitarrayindex = 'true'        
    }
    if (project.ext.use16bitarrayindex != 'true'
            && project.ext.use16bitarrayindex != 'false') {
        throw new InvalidUserDataException("Invalid value for use16bitarrayindex" + project.ext.use16bitarrayindex)        
    }
}

if (!project.hasProperty('useconstantshiftoptimisation')) {
    project.ext.useconstantshiftoptimisation = 'true'
} else {
    if (project.ext.useconstantshiftoptimisation == '') {
        project.ext.useconstantshiftoptimisation = 'true'        
    }
    if (project.ext.useconstantshiftoptimisation != 'true'
            && project.ext.useconstantshiftoptimisation != 'false') {
        throw new InvalidUserDataException("Invalid value for useconstantshiftoptimisation" + project.ext.useconstantshiftoptimisation)        
    }
}

if (!project.hasProperty('usesimul')) {
    project.ext.usesimul = 'true'
} else {
    if (project.ext.usesimul == '') {
        project.ext.usesimul = 'true'        
    }
    if (project.ext.usesimul != 'true'
            && project.ext.usesimul != 'false') {
        throw new InvalidUserDataException("Invalid value for usesimul" + project.ext.usesimul)        
    }
}

if (!project.hasProperty('usegetfield_a_fixed')) {
    project.ext.usegetfield_a_fixed = 'true'
} else {
    if (project.ext.usegetfield_a_fixed == '') {
        project.ext.usegetfield_a_fixed = 'true'        
    }
    if (project.ext.usegetfield_a_fixed != 'true'
            && project.ext.usegetfield_a_fixed != 'false') {
        throw new InvalidUserDataException("Invalid value for usegetfield_a_fixed" + project.ext.usegetfield_a_fixed)        
    }
}

if (!project.hasProperty('usebasebenchmark')) {
    project.ext.usebasebenchmark = 'false'
} else {
    if (project.ext.usebasebenchmark == '') {
        project.ext.usebasebenchmark = 'true'        
    }
    if (project.ext.usebasebenchmark != 'true'
            && project.ext.usebasebenchmark != 'false') {
        throw new InvalidUserDataException("Invalid value for usebasebenchmark" + project.ext.usebasebenchmark)        
    }
    if (project.ext.usebasebenchmark == 'true') {
        project.ext.aotbm = project.ext.aotbm + '_base'
    }
}

if (!project.hasProperty('aotmarkloopregs')) {
    if (project.ext.use16bitarrayindex == 'true') {
        project.ext.aotmarkloopregs = (project.ext.aotstackcachesize.toInteger() - 4).toString()
    } else {
        project.ext.aotmarkloopregs = (project.ext.aotstackcachesize.toInteger() - 5).toString() // because we may need one more during array stores
    }
}

if (project.ext.aotstackcachesize.toInteger() > 11) {
    throw new InvalidUserDataException("Max size for stack cache is 11 words")
}

binaries.all {
    cCompiler.args "-D AOT_STRATEGY_${project.ext.aotstrat.toUpperCase()}"
    cCompiler.args "-D RTC_STACKCACHE_NUMBER_OF_CACHE_REG_PAIRS_TO_USE=${project.ext.aotstackcachesize}"
    cCompiler.args "-D RTC_MARKLOOP_MAX_NUMBER_OF_IDX_TO_PIN=${project.ext.aotmarkloopregs}"

    if (project.ext.useconstantshiftoptimisation == 'false') {
        cCompiler.args "-D NO_CONSTSHIFT"
    }
    if (project.ext.use16bitarrayindex == 'false') {
        cCompiler.args "-D ARRAYINDEX_32BIT"
    }
    if (project.ext.usesimul == 'false') {
        cCompiler.args "-D NO_SIMUL"
    }
    if (project.ext.usegetfield_a_fixed == 'false') {
        cCompiler.args "-D NO_GETFIELD_A_FIXED"
    }
    if (project.ext.uselightweightmethods == 'false') {
        cCompiler.args "-D NO_LIGHTWEIGHT_METHODS"
    }
    if (project.ext.safe == 'true') {
        cCompiler.args "-D AOT_SAFETY_CHECKS"
    }
    if (project.ext.safer == 'true') {
        cCompiler.args "-D AOT_SAFETY_CHECKS_READS"
    }
}

def getOutputDirName() {
    def outdirSTRAT='?'
    if (project.ext.aotstrat == 'baseline')
        outdirSTRAT='0BASE'
    if (project.ext.aotstrat == 'improvedpeephole')
        outdirSTRAT='1PEEP'
    if (project.ext.aotstrat == 'simplestackcache')
        outdirSTRAT='2SMPL'
    if (project.ext.aotstrat == 'poppedstackcache')
        outdirSTRAT='3POPD'
    if (project.ext.aotstrat == 'markloop')
        outdirSTRAT='4MARK'


    def outdirREGS=sprintf('%02d', project.ext.aotstackcachesize.toInteger())
    def outdirPINNED=project.ext.aotmarkloopregs

    def opt_simul=''
    if (project.ext.usesimul == 'true') {
        opt_simul = '_S1'        
    } else {
        opt_simul = '_S0'
    }

    def opt_getfield_a_fixed=''
    if (project.ext.usegetfield_a_fixed == 'true') {
        opt_getfield_a_fixed = '_G1'        
    } else {
        opt_getfield_a_fixed = '_G0'
    }

    def opt_16bitindex=''
    if (project.ext.use16bitarrayindex == 'true') {
        opt_16bitindex = '_A1'        
    } else {
        opt_16bitindex = '_A0'
    }

    def opt_constshift=''
    if (project.ext.useconstantshiftoptimisation == 'true')
        opt_constshift='_C1'
    else
        opt_constshift='_C0'

    def opt_lightweight=''
    if (project.ext.uselightweightmethods == 'false')
        opt_lightweight='_NOLW'

    def opt_basebenchmark=''
    if (project.ext.usebasebenchmark == 'true')
        opt_basebenchmark='_BASE'

    def opt_safety=''
    if (project.ext.safe == 'true')
        opt_safety='_SAFE'
    if (project.ext.safer == 'true')
        opt_safety+='R'


    if (project.ext.aotstrat == 'baseline' || project.ext.aotstrat == 'improvedpeephole') {
        return "results_${outdirSTRAT}_R___P_${opt_constshift}${opt_16bitindex}${opt_simul}${opt_getfield_a_fixed}${opt_lightweight}${opt_safety}${opt_basebenchmark}"
    } else if (project.ext.aotstrat == 'simplestackcache' || project.ext.aotstrat == 'poppedstackcache') {
        return "results_${outdirSTRAT}_R${outdirREGS}_P_${opt_constshift}${opt_16bitindex}${opt_simul}${opt_getfield_a_fixed}${opt_lightweight}${opt_safety}${opt_basebenchmark}"
    } else {
        return "results_${outdirSTRAT}_R${outdirREGS}_P${outdirPINNED}${opt_constshift}${opt_16bitindex}${opt_simul}${opt_getfield_a_fixed}${opt_lightweight}${opt_safety}${opt_basebenchmark}"
    }
}

project.ext.aotTraceResultsDirName = getOutputDirName()
