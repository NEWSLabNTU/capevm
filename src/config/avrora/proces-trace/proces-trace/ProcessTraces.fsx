#r "binaries/fspickler.1.5.2/lib/net45/FsPickler.dll"

#load "Datatypes.fsx"
#load "Helpers.fsx"
#load "AVR.fsx"
#load "JVM.fsx"
#load "ResultsToString.fsx"

open System
open System.IO
open System.Linq
open System.Text.RegularExpressions
open System.Runtime.Serialization
open Nessos.FsPickler
open Datatypes
open Helpers
open ResultsToString

// The infusion header isn't necessary anymore now that Avrora will put the method name in
// rtcdata.xml, but let's keep it around in case it comes in handy later.
//type DarjeelingInfusionHeaderXml = XmlProvider<"infusionheader-example.dih", Global=true>
//type Dih = DarjeelingInfusionHeaderXml.Dih

let JvmInstructionFromXml (xml : RtcdataXml.JavaInstruction) =
    {
        JvmInstruction.index = xml.Index
        text = Uri.UnescapeDataString(xml.Text)
    }
let AvrInstructionFromXml (xml : RtcdataXml.AvrInstruction) =
    let opcode = Convert.ToInt32((xml.Opcode.Trim()), 16)
    {
        AvrInstruction.address = Convert.ToInt32(xml.Address.Trim(), 16)
        opcode = opcode
        text = Uri.UnescapeDataString(xml.Text)
    }

// Input: the optimised avr code, and a list of tuples of unoptimised avr instructions and the jvm instruction that generated them
// Returns: a list of tuples (optimised avr instruction, unoptimised avr instruction, corresponding jvm index)
//          the optimised avr instruction may be None for instructions that were removed completely by the optimiser
let rec matchOptUnopt (optimisedAvr : AvrInstruction list) (unoptimisedAvr : (AvrInstruction*JvmInstruction) list) =
    let isAOT_PUSH x = AVR.is AVR.PUSH (x.opcode) || AVR.is AVR.ST_XINC (x.opcode) // AOT uses 2 stacks
    let isAOT_POP x = AVR.is AVR.POP (x.opcode) || AVR.is AVR.LD_DECX (x.opcode)
    let isMOV x = AVR.is AVR.MOV (x.opcode)
    let isMOVW x = AVR.is AVR.MOVW (x.opcode)
    let isBREAK x = AVR.is AVR.BREAK (x.opcode)
    let isNOP x = AVR.is AVR.NOP (x.opcode)
    let isJMP x = AVR.is AVR.JMP (x.opcode)
    let isRJMP x = AVR.is AVR.RJMP (x.opcode)
    let isBRANCH x = AVR.is AVR.BREQ (x.opcode) || AVR.is AVR.BRGE (x.opcode) || AVR.is AVR.BRLT (x.opcode) || AVR.is AVR.BRNE (x.opcode)
    let isBRANCH_BY_BYTES x y = isBRANCH x && ((((x.opcode) &&& (0x03F8)) >>> 2) = y) // avr opcode BRxx 0000 00kk kkkk k000, with k the offset in WORDS (thus only shift right by 2, not 3, to get the number of bytes)

    let isMOV_MOVW_PUSH_POP x = isMOV x || isMOVW x || isAOT_PUSH x || isAOT_POP x
    match optimisedAvr, unoptimisedAvr with
    // Identical instructions: match and consume both
    | optimisedHead :: optimisedTail, (unoptimisedHead, jvmHead) :: unoptTail when optimisedHead.text = unoptimisedHead.text
        -> (Some optimisedHead, unoptimisedHead, jvmHead) :: matchOptUnopt optimisedTail unoptTail
    // Match a MOV to a single PUSH instruction (bit arbitrary whether to count the cycle for the PUSH or POP that was optimised)
    | optMOV :: optTail, (unoptPUSH, jvmHead) :: unoptTail when isMOV(optMOV) && isAOT_PUSH(unoptPUSH)
        -> (Some optMOV, unoptPUSH, jvmHead)
            :: matchOptUnopt optTail unoptTail
    // Match a MOVW to two PUSH instructions (bit arbitrary whether to count the cycle for the PUSH or POP that was optimised)
    | optMOVW :: optTail, (unoptPUSH1, jvmHead1) :: (unoptPUSH2, jvmHead2) :: unoptTail when isMOVW(optMOVW) && isAOT_PUSH(unoptPUSH1) && isAOT_PUSH(unoptPUSH2)
        -> (Some optMOVW, unoptPUSH1, jvmHead1)
            :: (None, unoptPUSH2, jvmHead2)
            :: matchOptUnopt optTail unoptTail
    // If the unoptimised head is a MOV PUSH or POP, skip it
    | _, (unoptimisedHead, jvmHead) :: unoptTail when isMOV_MOVW_PUSH_POP(unoptimisedHead)
        -> (None, unoptimisedHead, jvmHead) :: matchOptUnopt optimisedAvr unoptTail
    // BREAK signals a branchtag that would have been replaced in the optimised code by a
    // branch to the real address, possibly followed by one or two NOPs
    | _, (unoptBranchtag, jvmBranchtag) :: (unoptBranchtag2, jvmBranchtag2) :: unoptTail when isBREAK(unoptBranchtag)
        -> match optimisedAvr with
            // Short conditional jump, followed by a JMP or RJMP which was generated by a GOTO -> only the BR should match with the current JVM instruction
            | optBR :: optJMPRJMP :: optNoJMPRJMP :: optTail when isBRANCH(optBR) && (isJMP(optJMPRJMP) || isRJMP(optJMPRJMP)) && not (isJMP(optNoJMPRJMP) || isRJMP(optNoJMPRJMP)) && isBREAK(fst(unoptTail |> List.head))
                -> (Some optBR, unoptBranchtag, jvmBranchtag)
                    :: matchOptUnopt (optJMPRJMP :: optNoJMPRJMP :: optTail) unoptTail
            // Long conditional jump (branch by 2 or 4 bytes to jump over the next RJMP or JMP)
            | optBR :: optJMP :: optTail when ((isBRANCH_BY_BYTES optBR 2) || (isBRANCH_BY_BYTES optBR 4)) && isJMP(optJMP)
                -> (Some optBR, unoptBranchtag, jvmBranchtag)
                    :: (Some optJMP, unoptBranchtag, jvmBranchtag)
                    :: matchOptUnopt optTail unoptTail
            // Mid range conditional jump (branch by 2 or 4 bytes to jump over the next RJMP or JMP)
            | optBR :: optRJMP :: optTail when ((isBRANCH_BY_BYTES optBR 2) || (isBRANCH_BY_BYTES optBR 4)) && isRJMP(optRJMP)
                -> (Some optBR, unoptBranchtag, jvmBranchtag)
                    :: (Some optRJMP, unoptBranchtag, jvmBranchtag)
                    :: matchOptUnopt optTail unoptTail
            // Short conditional jump
            | optBR :: optTail when isBRANCH(optBR)
                -> (Some optBR, unoptBranchtag, jvmBranchtag)
                    :: matchOptUnopt optTail unoptTail
            // Uncondtional long jump
            | optJMP :: optTail when isJMP(optJMP)
                -> (Some optJMP, unoptBranchtag, jvmBranchtag)
                    :: matchOptUnopt optTail unoptTail
            // Uncondtional mid range jump
            | optRJMP :: optTail when isRJMP(optRJMP)
                -> (Some optRJMP, unoptBranchtag, jvmBranchtag)
                    :: matchOptUnopt optTail unoptTail
            | head :: tail -> failwith ("Incorrect branchtag @ address " + head.address.ToString() + ": " + head.text + " / " + unoptBranchtag2.text)
            | _ -> failwith "Incorrect branchtag"
    | [], [] -> [] // All done.
    | head :: tail, [] -> failwith ("Some instructions couldn't be matched(1): " + head.text)
    | [], (head, jvm) :: tail -> failwith ("Some instructions couldn't be matched(2): " + head.text)
    | head1 :: tail1, (head2, jvm) :: tail2 -> failwith ("Some instructions couldn't be matched: " + head1.address.ToString() + ":" + head1.text + "   +   " + head2.address.ToString() + ":" + head2.text)

// Input: the original Java instructions, trace data from avrora profiler, and the output from matchOptUnopt
// Returns: a list of ResultJava records, showing the optimised code per original JVM instructions, and amount of cycles spent per optimised instruction
let addCountersAndDebugData (jvmInstructions : JvmInstruction list) (countersForAddressAndInst : int -> int -> ExecCounters) (matchedResults : (AvrInstruction option*AvrInstruction*JvmInstruction) list) (possiblyEmptyDjDebugDatas : DJDebugData list) =
    let djDebugDatas = match possiblyEmptyDjDebugDatas with
                       | [] -> jvmInstructions |> List.map (fun x -> DJDebugData.empty) // If we don't have debug data, just use a list of empty DJDebugDatas of equal length as jvmInstructions
                       | _ -> (DJDebugData.empty :: possiblyEmptyDjDebugDatas)
    List.zip jvmInstructions djDebugDatas // Add an empty entry to debug data to match the method preamble
        |> List.map
        (fun (jvm, debugdata) ->
            let resultsForThisJvm = matchedResults |> List.filter (fun b -> let (_, _, jvm2) = b in jvm.index = jvm2.index) in
            let resultsWithCounters = resultsForThisJvm |> List.map (fun (opt, unopt, _) ->
                  let counters = match opt with
                                 | None -> ExecCounters.empty
                                 | Some(optValue) -> countersForAddressAndInst optValue.address optValue.opcode
                  { unopt = unopt; opt = opt; counters = counters }) in
            let foldAvrCountersToJvmCounters a b =
                { cycles = a.cycles+b.cycles; executions = (if a.executions > 0 then a.executions else b.executions); size = a.size+b.size; count = a.count+b.count }
            { jvm = jvm
              avr = resultsWithCounters
              counters = resultsWithCounters |> List.map (fun r -> r.counters) |> List.fold (foldAvrCountersToJvmCounters) ExecCounters.empty
              djDebugData = debugdata })

let getTimersFromStdout (stdoutlog : string list) =
    let pattern = "Timer (\w+) ran (\d+) times for a total of (\d+) cycles."
    stdoutlog |> List.map (fun line -> Regex.Match(line, pattern))
              |> List.filter (fun regexmatch -> regexmatch.Success)
              |> List.map (fun regexmatch -> (regexmatch.Groups.[1].Value, Int32.Parse(regexmatch.Groups.[3].Value)))
              |> List.sortBy (fun (timer, cycles) -> match timer with "NATIVE" -> 1 | "AOT" -> 2 | "JAVA" -> 3 | _ -> 4)

let getNativeInstructionsFromObjdump (objdumpOutput : string list) (countersForAddressAndInst : int -> int -> ExecCounters) =
    let startIndex = objdumpOutput |> List.findIndex (fun line -> Regex.IsMatch(line, "^[0-9a-fA-F]+ <rtcbenchmark_measure_native_performance(\.constprop\.\d*)?>:$"))
    let disasmTail = objdumpOutput |> List.skip (startIndex + 1)
    let endIndex = disasmTail |> List.findIndex (fun line -> Regex.IsMatch(line, "^[0-9a-fA-F]+ <.*>:$"))
    let disasm = disasmTail |> List.take endIndex |> List.filter ((<>) "")
    let pattern = "^\s*([0-9a-fA-F]+):((\s[0-9a-fA-F][0-9a-fA-F])+)\s+(\S.*)$"
    let regexmatches = disasm |> List.map (fun line -> Regex.Match(line, pattern))
    let avrInstructions = regexmatches |> List.map (fun regexmatch ->
        let opcodeBytes = regexmatch.Groups.[2].Value.Split(' ') |> Array.map (fun x -> Convert.ToInt32(x.Trim(), 16))
        let opcode = if (opcodeBytes.Length = 2)
                     then ((opcodeBytes.[1] <<< 8) + opcodeBytes.[0])
                     else ((opcodeBytes.[3] <<< 24) + (opcodeBytes.[2] <<< 16) + (opcodeBytes.[1] <<< 8) + opcodeBytes.[0])
        {
            AvrInstruction.address = Convert.ToInt32(regexmatch.Groups.[1].Value, 16)
            opcode = opcode
            text = regexmatch.Groups.[4].Value
        })
    avrInstructions |> List.map (fun avr -> (avr, countersForAddressAndInst avr.address avr.opcode))

let parseDJDebug (allLines : string list) =
  let regexLine = Regex("^\s*(?<byteOffset>\d\d\d\d);[^;]*;[^;]*;(?<text>[^;]*);(?<stackBefore>[^;]*);(?<stackAfter>[^;]*);.*")
  let regexStackElement = Regex("^(?<byteOffset>\d+)(?<datatype>[a-zA-Z]+)$")

  let startIndex = allLines |> List.findIndex (fun line -> Regex.IsMatch(line, "^\s*method.*rtcbenchmark_measure_java_performance$"))
  let linesTail = allLines |> List.skip (startIndex + 3)
  let endIndex = linesTail |> List.findIndex (fun line -> Regex.IsMatch(line, "^\s*}\s*$"))
  let lines = linesTail |> List.take endIndex |> List.filter ((<>) "")

  // System.Console.WriteLine (String.Join("\r\n", lines))

  let regexLineMatches = lines |> List.map (fun x -> regexLine.Match(x))
  let byteOffsetToInstOffset = regexLineMatches |> List.mapi (fun i m -> (Int32.Parse(m.Groups.["byteOffset"].Value.Trim()), i)) |> Map.ofList
  let stackStringToStack (stackString: string) =
      let split = stackString.Split(',')
                  |> Seq.toList
                  |> List.map (fun x -> match x.IndexOf('(') with // Some elements are in the form 20Short(Byte) to indicate Darjeeling knows the short value only contains a byte. Strip this information for now.
                                        | -1 -> x
                                        | index -> x.Substring(0, index))
                  |> List.filter ((<>) "")
      let regexElementMatches = split |> List.map (fun x -> regexStackElement.Match(x))
      // Temporarily just fill each index with 0 since the debug output from Darjeeling has a bug when instructions are replaced. The origin of each stack element is determined before replacing DUP and POP instructions.
      // So after replacing them, the indexes are no longer valid. Too much work to fix it properly in DJ for now. Will do that later if necessary.3
      // regexElementMatches |> List.map (fun m -> let byteOffset = Int32.Parse(m.Groups.["byteOffset"].Value) in
      //                                           let instOffset = if (Map.containsKey byteOffset byteOffsetToInstOffset)
      //                                                            then Map.find byteOffset byteOffsetToInstOffset
      //                                                            else failwith ("Key not found!!!! " + byteOffset.ToString() + " in " + string) in
      //                                           let datatype = (m.Groups.["datatype"].Value |> StackDatatypeFromString) in
      //                                           { StackElement.origin=instOffset; datatype=datatype })
      regexElementMatches |> List.map (fun m -> { StackElement.origin=0; datatype=(m.Groups.["datatype"].Value |> StackDatatypeFromString) })
  regexLineMatches |> List.mapi (fun i m -> { byteOffset = Int32.Parse(m.Groups.["byteOffset"].Value.Trim());
                                          instOffset = i;
                                          text = m.Groups.["text"].Value.Trim();
                                          stackBefore = (m.Groups.["stackBefore"].Value.Trim() |> stackStringToStack);
                                          stackAfter = (m.Groups.["stackAfter"].Value.Trim()  |> stackStringToStack) })

// Process trace main function
let processMethodTrace benchmark (methodImpl : MethodImpl) (countersForAddressAndInst : int -> int -> ExecCounters) (stdoutlog : string list) (disasm : string list) (djdebuglines : string list) =
    printfn "Processing %s" (methodImpl.Method)
    let optimisedAvr = methodImpl.AvrInstructions |> Seq.map AvrInstructionFromXml |> Seq.toList
    let unoptimisedAvrWithJvmIndex =
        methodImpl.JavaInstructions |> Seq.map (fun jvm -> jvm.UnoptimisedAvr.AvrInstructions |> Seq.map (fun avr -> (AvrInstructionFromXml avr, JvmInstructionFromXml jvm)))
                                    |> Seq.concat
                                    |> Seq.toList

    let matchedResult = matchOptUnopt optimisedAvr unoptimisedAvrWithJvmIndex
    let djdebugdata = match (methodImpl.Method.Contains("rtcbenchmark_measure_java_performance")) with
                      | true -> parseDJDebug djdebuglines
                      | false -> [] // We only need this for the detailed analysis report of small benchmarks. For full application profile just use an empty list.
    let processedJvmInstructions = addCountersAndDebugData (methodImpl.JavaInstructions |> Seq.map JvmInstructionFromXml |> Seq.toList) countersForAddressAndInst matchedResult djdebugdata
    let stopwatchTimers = getTimersFromStdout stdoutlog

    let countersPerJvmOpcodeAOTJava =
        processedJvmInstructions
            |> List.filter (fun r -> r.jvm.text <> "Method preamble")
            |> groupFold (fun r -> r.jvm.text.Split().First()) (fun r -> r.counters) (+) ExecCounters.empty
            |> List.map (fun (opc, cnt) -> (JVM.getCategoryForJvmOpcode opc, opc, cnt))
            |> List.sortBy (fun (cat, opc, _) -> cat+opc)

    let countersPerAvrOpcodeAOTJava =
        processedJvmInstructions
            |> List.map (fun r -> r.avr)
            |> List.concat
            |> List.filter (fun avr -> avr.opt.IsSome)
            |> List.map (fun avr -> (AVR.getOpcodeForInstruction avr.opt.Value.opcode avr.opt.Value.text, avr.counters))
            |> groupFold fst snd (+) ExecCounters.empty
            |> List.map (fun (opc, cnt) -> (AVR.opcodeCategory opc, AVR.opcodeName opc, cnt))
            |> List.sortBy (fun (cat, opc, _) -> cat+opc)

    let nativeCInstructions = getNativeInstructionsFromObjdump disasm countersForAddressAndInst
    let countersPerAvrOpcodeNativeC =
        nativeCInstructions
            |> List.map (fun (avr, cnt) -> (AVR.getOpcodeForInstruction avr.opcode avr.text, cnt))
            |> groupFold fst snd (+) ExecCounters.empty
            |> List.map (fun (opc, cnt) -> (AVR.opcodeCategory opc, AVR.opcodeName opc, cnt))
            |> List.sortBy (fun (cat, opc, _) -> cat+opc)

    let codesizeJava = methodImpl.JvmMethodSize
    let codesizeJavaBranchCount = methodImpl.BranchCount
    let codesizeJavaBranchTargetCount = methodImpl.BranchTargets |> Array.length
    let codesizeJavaMarkloopCount = methodImpl.MarkloopCount
    let codesizeJavaMarkloopTotalSize = methodImpl.MarkloopTotalSize
    let codesizeJavaWithoutBranchOverhead = codesizeJava - (2*codesizeJavaBranchCount) - codesizeJavaBranchTargetCount
    let codesizeJavaWithoutBranchMarkloopOverhead = codesizeJava - (2*codesizeJavaBranchCount) - codesizeJavaBranchTargetCount - codesizeJavaMarkloopTotalSize
    let codesizeAOT =
        let numberOfBranchTargets = methodImpl.BranchTargets |> Array.length
        methodImpl.AvrMethodSize - (4*numberOfBranchTargets) // We currently keep the branch table at the head of the method, but actually we don't need it anymore after code generation, so it shouldn't count for code size.
    let codesizeC =
        let startAddress = (nativeCInstructions |> List.head |> fst).address
        let lastInList x = x |> List.reduce (fun _ x -> x)
        let endAddress = (nativeCInstructions |> lastInList |> fst).address
        endAddress - startAddress + 2 // assuming the function ends in a 2 byte opcode.
    let getTimer timer =
        match stopwatchTimers |> List.tryFind (fun (t,c) -> t=timer) with
        | Some(x) -> x |> snd
        | None -> 0

    {
        benchmark = benchmark
        jvmInstructions = processedJvmInstructions
        nativeCInstructions = nativeCInstructions |> Seq.toList
        passedTestJava = stdoutlog |> List.exists (fun line -> line.Contains("JAVA OK."))
        passedTestAOT = stdoutlog |> List.exists (fun line -> line.Contains("RTC OK."))

        codesizeJava = codesizeJava
        codesizeJavaBranchCount = codesizeJavaBranchCount
        codesizeJavaBranchTargetCount = codesizeJavaBranchTargetCount
        codesizeJavaMarkloopCount = codesizeJavaMarkloopCount
        codesizeJavaMarkloopTotalSize = codesizeJavaMarkloopTotalSize
        codesizeJavaWithoutBranchOverhead = codesizeJavaWithoutBranchOverhead
        codesizeJavaWithoutBranchMarkloopOverhead = codesizeJavaWithoutBranchMarkloopOverhead
        codesizeAOT = codesizeAOT
        codesizeC = codesizeC

        cyclesStopwatchJava = (getTimer "JAVA")
        cyclesStopwatchAOT = (getTimer "AOT")
        cyclesStopwatchC = (getTimer "NATIVE")

        countersPerJvmOpcodeAOTJava = countersPerJvmOpcodeAOTJava
        countersPerAvrOpcodeAOTJava = countersPerAvrOpcodeAOTJava
        countersPerAvrOpcodeNativeC = countersPerAvrOpcodeNativeC
    }

let ProcessTrace (outputType : string) (resultsdir : string) =
    let benchmark = (Path.GetFileName(resultsdir))
    let rtcdata = RtcdataXml.Load(String.Format("{0}/rtcdata.xml", resultsdir))
    let profilerdata = ProfilerdataXml.Load(String.Format("{0}/profilerdata.xml", resultsdir)).Instructions |> Seq.toList
    let stdoutlog = System.IO.File.ReadLines(String.Format("{0}/stdoutlog.txt", resultsdir)) |> Seq.toList
    let disasm = System.IO.File.ReadLines(String.Format("{0}/darjeeling.S", resultsdir)) |> Seq.toList
    let djdebuglines = System.IO.File.ReadLines(String.Format("{0}/jlib_bm_{1}.debug", resultsdir, benchmark)) |> Seq.toList

    let profilerdataPerAddress = profilerdata |> List.map (fun x -> (Convert.ToInt32(x.Address.Trim(), 16), x))
    let countersForAddressAndInst address inst =
        match profilerdataPerAddress |> List.tryFind (fun (address2,inst) -> address = address2) with
        | None -> failwith (String.Format ("No profilerdata found for address {0}", address))
        | Some(_, profiledInstruction) ->
            {
                executions = profiledInstruction.Executions
                cycles = (profiledInstruction.Cycles+profiledInstruction.CyclesSubroutine)
                count = 1
                size = AVR.instructionSize inst
            }
    match outputType with
    | "normal" ->
      // Find the benchmark method
      let methodImpl = rtcdata.MethodImpls |> Seq.find (fun impl -> impl.Method.Contains("rtcbenchmark_measure_java_performance"))
      let results = processMethodTrace benchmark methodImpl countersForAddressAndInst stdoutlog disasm djdebuglines

      let txtFilename = resultsdir + ".txt"
      let xmlFilename = resultsdir + ".xml"

      File.WriteAllText (txtFilename, (resultsToString results))
      Console.Error.WriteLine ("Wrote output to " + txtFilename)

      let xmlSerializer = FsPickler.CreateXmlSerializer(indent = true)
      File.WriteAllText (xmlFilename, (xmlSerializer.PickleToString results))
      Console.Error.WriteLine ("Wrote output to " + xmlFilename)
    | "profile" ->
      let methodsExclAbstracts = rtcdata.MethodImpls |> Seq.filter (fun methodImpl -> methodImpl.JavaInstructions.Length > 1) // Bug in RTC: abstract methods become just a method prologue
      let allMethodResults = methodsExclAbstracts |> Seq.map (fun methodImpl -> (methodImpl, (processMethodTrace benchmark methodImpl countersForAddressAndInst stdoutlog disasm djdebuglines)))
      let allMethodResultsTexts = allMethodResults |> Seq.map (fun (methodImpl, results) -> (resultsToProfiledText methodImpl results))
                                                   |> Seq.fold (fun r s -> r + s) ""

      let txtFilename = resultsdir + "_profile.txt"

      File.WriteAllText (txtFilename, allMethodResultsTexts)
    | _ -> failwith "unknown output type"

let ProcessResultsDir (directory) =
    let subdirectories = (Directory.GetDirectories(directory))
    match subdirectories |> Array.length with
    | 0 -> ProcessTrace "normal" directory
    | _ -> subdirectories |> Array.iter (ProcessTrace "normal")

let main(args : string[]) =
    Console.Error.WriteLine ("START " + (DateTime.Now.ToString()))
    let arg = (Array.get args 1)
    match arg with
    | "all" -> 
        let directory = (Array.get args 2)
        let subdirectories = (Directory.GetDirectories(directory))
        subdirectories |> Array.filter (fun d -> (Path.GetFileName(d).StartsWith("results_")))
                       |> Array.iter ProcessResultsDir
    | "profile" ->
        // Generate a complete profile for a single directory. Maybe extend this later to include multiple dirs, but for now we only need one. (because we only use it for coremark)
        let resultsdir = (Array.get args 2)
        ProcessTrace "profile" resultsdir
    | resultsbasedir -> ProcessResultsDir resultsbasedir
    Console.Error.WriteLine ("STOP " + (DateTime.Now.ToString()))
    1

main(fsi.CommandLineArgs)



















